// Code generated by protoc-gen-go.
// source: pkg/crowdsound/crowdsound_service.proto
// DO NOT EDIT!

/*
Package CrowdSound is a generated protocol buffer package.

It is generated from these files:
	pkg/crowdsound/crowdsound_service.proto

It has these top-level messages:
	ListSongsRequest
	ListSongsResponse
	ListTrendingArtistsRequest
	ListTrendingArtistsResponse
	PostSongRequest
	PostSongResponse
	VoteSongRequest
	VoteSongResponse
*/
package CrowdSound

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type ListSongsRequest struct {
}

func (m *ListSongsRequest) Reset()                    { *m = ListSongsRequest{} }
func (m *ListSongsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListSongsRequest) ProtoMessage()               {}
func (*ListSongsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type ListSongsResponse struct {
	Name      string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	IsPlaying bool   `protobuf:"varint,2,opt,name=isPlaying" json:"isPlaying,omitempty"`
}

func (m *ListSongsResponse) Reset()                    { *m = ListSongsResponse{} }
func (m *ListSongsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListSongsResponse) ProtoMessage()               {}
func (*ListSongsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type ListTrendingArtistsRequest struct {
}

func (m *ListTrendingArtistsRequest) Reset()                    { *m = ListTrendingArtistsRequest{} }
func (m *ListTrendingArtistsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListTrendingArtistsRequest) ProtoMessage()               {}
func (*ListTrendingArtistsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type ListTrendingArtistsResponse struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Score int32  `protobuf:"varint,2,opt,name=score" json:"score,omitempty"`
}

func (m *ListTrendingArtistsResponse) Reset()                    { *m = ListTrendingArtistsResponse{} }
func (m *ListTrendingArtistsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListTrendingArtistsResponse) ProtoMessage()               {}
func (*ListTrendingArtistsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type PostSongRequest struct {
	Name   string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Artist string `protobuf:"bytes,2,opt,name=artist" json:"artist,omitempty"`
	Genre  string `protobuf:"bytes,3,opt,name=genre" json:"genre,omitempty"`
}

func (m *PostSongRequest) Reset()                    { *m = PostSongRequest{} }
func (m *PostSongRequest) String() string            { return proto.CompactTextString(m) }
func (*PostSongRequest) ProtoMessage()               {}
func (*PostSongRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type PostSongResponse struct {
}

func (m *PostSongResponse) Reset()                    { *m = PostSongResponse{} }
func (m *PostSongResponse) String() string            { return proto.CompactTextString(m) }
func (*PostSongResponse) ProtoMessage()               {}
func (*PostSongResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type VoteSongRequest struct {
	Name   string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Artist string `protobuf:"bytes,2,opt,name=artist" json:"artist,omitempty"`
	Like   bool   `protobuf:"varint,3,opt,name=like" json:"like,omitempty"`
}

func (m *VoteSongRequest) Reset()                    { *m = VoteSongRequest{} }
func (m *VoteSongRequest) String() string            { return proto.CompactTextString(m) }
func (*VoteSongRequest) ProtoMessage()               {}
func (*VoteSongRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type VoteSongResponse struct {
}

func (m *VoteSongResponse) Reset()                    { *m = VoteSongResponse{} }
func (m *VoteSongResponse) String() string            { return proto.CompactTextString(m) }
func (*VoteSongResponse) ProtoMessage()               {}
func (*VoteSongResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func init() {
	proto.RegisterType((*ListSongsRequest)(nil), "CrowdSound.ListSongsRequest")
	proto.RegisterType((*ListSongsResponse)(nil), "CrowdSound.ListSongsResponse")
	proto.RegisterType((*ListTrendingArtistsRequest)(nil), "CrowdSound.ListTrendingArtistsRequest")
	proto.RegisterType((*ListTrendingArtistsResponse)(nil), "CrowdSound.ListTrendingArtistsResponse")
	proto.RegisterType((*PostSongRequest)(nil), "CrowdSound.PostSongRequest")
	proto.RegisterType((*PostSongResponse)(nil), "CrowdSound.PostSongResponse")
	proto.RegisterType((*VoteSongRequest)(nil), "CrowdSound.VoteSongRequest")
	proto.RegisterType((*VoteSongResponse)(nil), "CrowdSound.VoteSongResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for CrowdSound service

type CrowdSoundClient interface {
	// ListSongs streams all songs known to the CrowdSound service.
	//
	// Because the amount of songs may be massive, it is up to the clients
	// to implement pagination and/or stream termination (with the exception of
	// end-of-stream). For example, a client may request 20 from the stream,
	// display to user, and then wait for the user to keep scrolling before
	// requesting. Alternatively, if the user is no longer browsing, the
	// stream can be terminated.
	ListSongs(ctx context.Context, in *ListSongsRequest, opts ...grpc.CallOption) (CrowdSound_ListSongsClient, error)
	// ListTrendingArtists returns an ordered list of artists, based on
	// trending value.
	//
	// As with ListSongs, it is up to the client to control pagination and stream
	// termination (with the exception of end-of-stream).
	ListTrendingArtists(ctx context.Context, in *ListTrendingArtistsRequest, opts ...grpc.CallOption) (CrowdSound_ListTrendingArtistsClient, error)
	// PostSong informs the CrowdSound service of a 'Song' that the client
	// has. The 'Song' may or may not have all of the fields filled or present.
	PostSong(ctx context.Context, opts ...grpc.CallOption) (CrowdSound_PostSongClient, error)
	// VoteSong informs the CrowdSound service of a vote for a Song.
	VoteSong(ctx context.Context, in *VoteSongRequest, opts ...grpc.CallOption) (*VoteSongResponse, error)
}

type crowdSoundClient struct {
	cc *grpc.ClientConn
}

func NewCrowdSoundClient(cc *grpc.ClientConn) CrowdSoundClient {
	return &crowdSoundClient{cc}
}

func (c *crowdSoundClient) ListSongs(ctx context.Context, in *ListSongsRequest, opts ...grpc.CallOption) (CrowdSound_ListSongsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CrowdSound_serviceDesc.Streams[0], c.cc, "/CrowdSound.CrowdSound/ListSongs", opts...)
	if err != nil {
		return nil, err
	}
	x := &crowdSoundListSongsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CrowdSound_ListSongsClient interface {
	Recv() (*ListSongsResponse, error)
	grpc.ClientStream
}

type crowdSoundListSongsClient struct {
	grpc.ClientStream
}

func (x *crowdSoundListSongsClient) Recv() (*ListSongsResponse, error) {
	m := new(ListSongsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *crowdSoundClient) ListTrendingArtists(ctx context.Context, in *ListTrendingArtistsRequest, opts ...grpc.CallOption) (CrowdSound_ListTrendingArtistsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CrowdSound_serviceDesc.Streams[1], c.cc, "/CrowdSound.CrowdSound/ListTrendingArtists", opts...)
	if err != nil {
		return nil, err
	}
	x := &crowdSoundListTrendingArtistsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CrowdSound_ListTrendingArtistsClient interface {
	Recv() (*ListTrendingArtistsResponse, error)
	grpc.ClientStream
}

type crowdSoundListTrendingArtistsClient struct {
	grpc.ClientStream
}

func (x *crowdSoundListTrendingArtistsClient) Recv() (*ListTrendingArtistsResponse, error) {
	m := new(ListTrendingArtistsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *crowdSoundClient) PostSong(ctx context.Context, opts ...grpc.CallOption) (CrowdSound_PostSongClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CrowdSound_serviceDesc.Streams[2], c.cc, "/CrowdSound.CrowdSound/PostSong", opts...)
	if err != nil {
		return nil, err
	}
	x := &crowdSoundPostSongClient{stream}
	return x, nil
}

type CrowdSound_PostSongClient interface {
	Send(*PostSongRequest) error
	CloseAndRecv() (*PostSongResponse, error)
	grpc.ClientStream
}

type crowdSoundPostSongClient struct {
	grpc.ClientStream
}

func (x *crowdSoundPostSongClient) Send(m *PostSongRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *crowdSoundPostSongClient) CloseAndRecv() (*PostSongResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(PostSongResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *crowdSoundClient) VoteSong(ctx context.Context, in *VoteSongRequest, opts ...grpc.CallOption) (*VoteSongResponse, error) {
	out := new(VoteSongResponse)
	err := grpc.Invoke(ctx, "/CrowdSound.CrowdSound/VoteSong", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CrowdSound service

type CrowdSoundServer interface {
	// ListSongs streams all songs known to the CrowdSound service.
	//
	// Because the amount of songs may be massive, it is up to the clients
	// to implement pagination and/or stream termination (with the exception of
	// end-of-stream). For example, a client may request 20 from the stream,
	// display to user, and then wait for the user to keep scrolling before
	// requesting. Alternatively, if the user is no longer browsing, the
	// stream can be terminated.
	ListSongs(*ListSongsRequest, CrowdSound_ListSongsServer) error
	// ListTrendingArtists returns an ordered list of artists, based on
	// trending value.
	//
	// As with ListSongs, it is up to the client to control pagination and stream
	// termination (with the exception of end-of-stream).
	ListTrendingArtists(*ListTrendingArtistsRequest, CrowdSound_ListTrendingArtistsServer) error
	// PostSong informs the CrowdSound service of a 'Song' that the client
	// has. The 'Song' may or may not have all of the fields filled or present.
	PostSong(CrowdSound_PostSongServer) error
	// VoteSong informs the CrowdSound service of a vote for a Song.
	VoteSong(context.Context, *VoteSongRequest) (*VoteSongResponse, error)
}

func RegisterCrowdSoundServer(s *grpc.Server, srv CrowdSoundServer) {
	s.RegisterService(&_CrowdSound_serviceDesc, srv)
}

func _CrowdSound_ListSongs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListSongsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CrowdSoundServer).ListSongs(m, &crowdSoundListSongsServer{stream})
}

type CrowdSound_ListSongsServer interface {
	Send(*ListSongsResponse) error
	grpc.ServerStream
}

type crowdSoundListSongsServer struct {
	grpc.ServerStream
}

func (x *crowdSoundListSongsServer) Send(m *ListSongsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _CrowdSound_ListTrendingArtists_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListTrendingArtistsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CrowdSoundServer).ListTrendingArtists(m, &crowdSoundListTrendingArtistsServer{stream})
}

type CrowdSound_ListTrendingArtistsServer interface {
	Send(*ListTrendingArtistsResponse) error
	grpc.ServerStream
}

type crowdSoundListTrendingArtistsServer struct {
	grpc.ServerStream
}

func (x *crowdSoundListTrendingArtistsServer) Send(m *ListTrendingArtistsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _CrowdSound_PostSong_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CrowdSoundServer).PostSong(&crowdSoundPostSongServer{stream})
}

type CrowdSound_PostSongServer interface {
	SendAndClose(*PostSongResponse) error
	Recv() (*PostSongRequest, error)
	grpc.ServerStream
}

type crowdSoundPostSongServer struct {
	grpc.ServerStream
}

func (x *crowdSoundPostSongServer) SendAndClose(m *PostSongResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *crowdSoundPostSongServer) Recv() (*PostSongRequest, error) {
	m := new(PostSongRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _CrowdSound_VoteSong_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(VoteSongRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(CrowdSoundServer).VoteSong(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _CrowdSound_serviceDesc = grpc.ServiceDesc{
	ServiceName: "CrowdSound.CrowdSound",
	HandlerType: (*CrowdSoundServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "VoteSong",
			Handler:    _CrowdSound_VoteSong_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListSongs",
			Handler:       _CrowdSound_ListSongs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListTrendingArtists",
			Handler:       _CrowdSound_ListTrendingArtists_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PostSong",
			Handler:       _CrowdSound_PostSong_Handler,
			ClientStreams: true,
		},
	},
}

var fileDescriptor0 = []byte{
	// 331 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x92, 0x4f, 0x4f, 0x83, 0x30,
	0x18, 0xc6, 0x07, 0xba, 0xc9, 0xde, 0xe8, 0xe6, 0xea, 0x65, 0x61, 0x33, 0x31, 0x3d, 0xb8, 0x9d,
	0xd0, 0xa8, 0x27, 0x13, 0x4d, 0x74, 0x07, 0x63, 0xb2, 0xc3, 0xe2, 0x8c, 0x57, 0x83, 0xf0, 0x86,
	0xe0, 0x66, 0x8b, 0x2d, 0xf3, 0xcf, 0xd7, 0xf1, 0x63, 0xf9, 0x69, 0xa4, 0x30, 0x06, 0x6b, 0x30,
	0x7a, 0xa3, 0xef, 0xd3, 0xe7, 0xd7, 0xf2, 0x03, 0x18, 0x44, 0xb3, 0xe0, 0xc8, 0x13, 0xfc, 0xdd,
	0x97, 0x7c, 0xc1, 0xfc, 0xd2, 0xe3, 0xa3, 0x44, 0xf1, 0x16, 0x7a, 0xe8, 0x44, 0x82, 0xc7, 0x9c,
	0xc0, 0x48, 0x25, 0x53, 0x95, 0x50, 0x02, 0xbb, 0xe3, 0x50, 0xc6, 0x53, 0xce, 0x02, 0x79, 0x87,
	0xaf, 0x0b, 0x94, 0x31, 0x3d, 0x83, 0x4e, 0x69, 0x26, 0x23, 0xce, 0x24, 0x92, 0x6d, 0xd8, 0x64,
	0xee, 0x0b, 0x76, 0x8d, 0x03, 0x63, 0xd8, 0x24, 0x1d, 0x68, 0x86, 0x72, 0x32, 0x77, 0x3f, 0x43,
	0x16, 0x74, 0xcd, 0x64, 0x64, 0xd1, 0x3e, 0xd8, 0xaa, 0x75, 0x2f, 0x90, 0xf9, 0xc9, 0xf4, 0x4a,
	0xc4, 0xc9, 0x6a, 0xc5, 0x3c, 0x87, 0x5e, 0x65, 0x5a, 0x49, 0xdf, 0x81, 0xba, 0xf4, 0xb8, 0xc0,
	0x94, 0x5c, 0xa7, 0x97, 0xd0, 0x9e, 0xf0, 0xec, 0x3e, 0x4b, 0x9c, 0xb6, 0xbf, 0x05, 0x0d, 0x37,
	0x05, 0xa6, 0x85, 0xb4, 0x1f, 0x20, 0x4b, 0xfa, 0x1b, 0x6a, 0xa9, 0xde, 0xb1, 0xe8, 0x67, 0x07,
	0xd2, 0x0b, 0x68, 0x3f, 0xf0, 0x18, 0xff, 0xcf, 0x4c, 0xd2, 0x79, 0x38, 0xcb, 0x90, 0x96, 0x42,
	0x16, 0xf5, 0x0c, 0x79, 0xf2, 0x6d, 0x42, 0xc9, 0x2c, 0x19, 0x43, 0x73, 0x65, 0x91, 0xf4, 0x9d,
	0x22, 0x71, 0x74, 0xe1, 0xf6, 0xfe, 0x2f, 0xe9, 0xf2, 0xae, 0xb5, 0x63, 0x83, 0x3c, 0xc3, 0x5e,
	0x85, 0x3f, 0x72, 0xa8, 0x37, 0xab, 0xf5, 0xdb, 0x83, 0x3f, 0xf7, 0x95, 0xce, 0xba, 0x05, 0x2b,
	0xf7, 0x45, 0x7a, 0xe5, 0xa2, 0xf6, 0x15, 0xec, 0x7e, 0x75, 0x98, 0xa3, 0x86, 0x06, 0xb9, 0x01,
	0x2b, 0xf7, 0xb4, 0x8e, 0xd2, 0xe4, 0xaf, 0xa3, 0x74, 0xb5, 0xb4, 0x76, 0xdd, 0x82, 0x2d, 0xfc,
	0x70, 0x02, 0x11, 0x79, 0x5f, 0xa6, 0x39, 0x9a, 0x3e, 0x35, 0xd2, 0x5f, 0xf9, 0xf4, 0x27, 0x00,
	0x00, 0xff, 0xff, 0x53, 0xaf, 0x74, 0x8e, 0xf5, 0x02, 0x00, 0x00,
}
